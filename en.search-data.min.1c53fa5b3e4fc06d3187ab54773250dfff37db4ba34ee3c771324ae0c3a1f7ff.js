'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/clj-statecharts/docs/actions/','title':"Actions \u0026 Context",'section':"Docs",'content':"Actions \u0026amp; Context #  Actions #  Actions are side-effects that are executed on state transitions.\nThere are two kinds of actions:\n Actions that are executed when a transition happens Actions that are executed when transition in (entry) or transition out (exit) of a state  Transition Actions #  Instead of define a transition target as simply a keyword, you need to use the full form:\n{:on {:some-event {:target :some-state :actions some-action}}} The actions value can also be a vector, and the actions would be executed one by one.\n{:on {:some-event {:target :some-state :actions [action1 action2]}}} Entry/Exit Actions #  Entry actions are defined on a state, and are executed whenever this state is entered. Similar for exit actions - they are executed whenever leaving the state.\n{:states {:state1 {:entry some-action-on-entry :exit some-action-on-exit :on {...}}}} ;; entry/exit can also be vector of actions {:states {:state1 {:entry [action1 action2] :exit [action3 action4] :on {...}}}} Method Signature of the Action Functions #  The action function is invoked with two arguments: (state event)\n state is the current state event is the event that triggers the transition and execution of the action  Updating the State Context #  Actions can update the context of the state machine.\n(require \u0026#39;[statecharts.core :as fsm :refer [assign]]) (defn update-counter [state event] (update state :counter inc)) {:states {:state1 {:on {:some-event {:target :state2 :action (assign update-counter)}}}}} Note the action is wrapped with statecharts.core/assign. Without this it\u0026rsquo;s return value is ignored and the state context is not changed.\nThe event arg of update-counter would be {:type :some-event}. Extra keys could be passed when calling fsm/transition:\n(let [event {:type :some-event :k1 :v1 :k1 :v2}] (fsm/transition machine current-state event)) And the event argument passed to the update-counter would have these :k1 :k2 keys etc.\nThe Special Variable _prev-state in Action Functions #  During action execution time, _state already points to the new state after the transition.\nThe action functions could use the value under the _prev-state key of the context to access the previous state before the transition (e.g. for debugging, or archiving some information for later analysis).\nPlease note:\n Unlike _state, the _prev-state variable only exists during the transition and would not be available after that. If the transition is called with {:exec false}, the actions would be returned to the caller instead of being executed. In that case it would also have no access to _prev-state.  A Full Example #  (ns statecharts-samples.trigger-actions (:require [statecharts.core :as fsm])) (defn fire-cameras [\u0026amp; _] (println \u0026#34;Firing the traffic cameras!\u0026#34;)) (def machine (fsm/machine {:id :lights :initial :red :states {:green {:on {:timer :yellow}} :yellow {:on {:timer {:target :red :actions fire-cameras}}} :red {:on {:timer :green}}} :on {:power-outage :red}})) (def service (fsm/service machine)) (fsm/start service) ;; :red =\u0026gt; :green (fsm/send service :timer) ;; :green =\u0026gt; yellow (fsm/send service :timer) ;; :yellow =\u0026gt; :red ;; fire-cameras would be called here (fsm/send service :timer) "});index.add({'id':1,'href':'/clj-statecharts/docs/concepts/','title':"Concepts: Machine, State, Service",'section':"Docs",'content':"Concepts: Machine, State, Service #  Machine \u0026amp; State #   A machine is a specification of transitions, states, etc. It is immutable. A state is, well, a state. It represents the state of some system at some specific moment. It\u0026rsquo;s also immutable.  How is the state different from the machine?\n The machine is like a map (a chart of locations \u0026amp; directions, not a clojure map data structure). A map could indicate how one could go from one place to another. Likewise, a machine indicates how a system could transition from one state to another. The state is like a place on a map.  How is a machine like a map? The map itself is not in any place. It just contains all the directions. Similarly, the machine itself is not in any state. It just contains all the possible transitions.\nThe state itself (mainly) contains two piece of information:\n the current state value, e.g. :connecting, or [:connecting :handshake]. (see Hierarchical States for how to represent hierarchical states). the current state context, e.g. number of seconds to back off before next connection attempt.  The State Map #  The current state is expressed as a map like this:\n{:_state :waiting :user :jack :backoff 3000}  All keys that starts with an underscore (e.g. _state) is considered internal to clj-statecharts. Application code could read them, but should not modify them. All others keys are application-specific data, collectively called the \u0026ldquo;context\u0026rdquo; of the state machine.  State \u0026amp; Service #  How are machine/state connected to the higher level services?\nA service is stateful, and we need it for two reasons:\n We need a container of state to represent the state of system, which could transition over time. Actually it\u0026rsquo;s just an atom in the state record. For delayed transitions, we need someone to keep track of these scheduling information. In its essence a delayed transition is just a timer:  the timer is scheduled when entering the state if the machine transitions out of the state before the timer is fired, the timer shall be canceled.    "});index.add({'id':2,'href':'/clj-statecharts/docs/delayed/','title':"Delayed Transitions",'section':"Docs",'content':"Delayed Transitions #  Basic Delayed Transitions #  To specify a transition that shall happen automatically after some time, use the :after keyword:\n{:states {:s1 {:after [{:delay 1000 :target :s2 :guard some-condition-fn :actions some-action} {:delay 2000 :target :s3 :actions some-action}]}}} All transition features like guards and actions could be used here, as you can see in the code snippet above.\nDynamic Delay #  The amount of delay could be expressed as a context function.\nFor example, in a state machine that manages a websocket connection, the reconnection delay could be calculated as an exponential backoff.\n(defn calculate-backoff \u0026#34;Exponential backoff, with a upper limit of 15 seconds.\u0026#34; [state \u0026amp; _] (-\u0026gt; (js/Math.pow 2 (:retries state)) (* 1000) (min 15000))) (defn update-retries [state \u0026amp; _] (update state :retries inc)) ;; Part of the machine definition {:states {:connecting {:entry try-connect :on {:success-connect :connected}} :disconnected {:entry (assign update-retries) :after [{:delay calculate-backoff :target :connecting}]} :connected {:on {:connection-closed :disconnected}}}} Unit Testing a StateCharts That Uses Delayed Transitions #  When unit-testing a statecharts that uses delayed transitions, we don\u0026rsquo;t want to really wait for the exact delay to timeout.\nTo facilitate this, clj-statecharts provides a \u0026ldquo;simulated clock\u0026rdquo; to be used in unit tests. This clock could be manipulated by calling its advance method.\nIf you are interested, see this test case for inspiration.\nNote: if in your actions code you need to get the current time value, you shall not use OS API (i.e. (js/Date.now) or (System/currentTimeMillis)), but use (statecharts.clock/now). The latter returns the current time in milliseconds, and when the clock is a simulated one, it would return the value of the simulated time. This is the only way to make your statecharts unit-testing-friendly.\nNotes #    Delayed transitions currently only works in the CLJS. CLJ support is going to be added soon.\n  When using the Immutable API, the machine spec must have a :scheduler key that satisfies the statecharts.delayed.Scheduler protocol.\n  "});index.add({'id':3,'href':'/clj-statecharts/docs/xstate/','title':"Difference from XState",'section':"Docs",'content':"Difference from XState #  Why not use XState in CLJS? #   In XState the context can only be a plain js map. One can not use cljs objects (map/vector) as context, because xstate doesn\u0026rsquo;t preserve the context object\u0026rsquo;s prototype, because it uses Object.assign when updating the context. For a CLJS project, xstate may be good enough, but we still need a solution for CLJ projects. Last but not least, xstate uses strings to represent states everywhere, but in clj/cljs we tend to use keywords instead.  Unsupported XState/SCXML Features #   invoking another machine/promise/actor final states \u0026amp; done signals history states  These features may be implemented in the future.\nDifferent structure for the state map #  In xstate, the state object has two keys value and context\n{ value: \u0026#34;waiting\u0026#34;, context: { user: \u0026#34;jack\u0026#34;, backoff: 3000 } } But in clj-statecharts the state map is a flat map:\n{:_state :waiting :user \u0026#34;jack\u0026#34; :backoff 3000} In the state map, any underscored key (e.g. _state) is internal to clj-statecharts, which means your application code should not modify it (e.g. in an context function). The others are the application specific data (equivalent to the \u0026ldquo;context\u0026rdquo; of xstate).\nThe reason behind this is that after using the xstate-like two-level map structure in some real world projects, it\u0026rsquo;s obvious that the two-level map is hard to integrate into an existing project, e.g. putting the state inside a re-frame db.\n"});index.add({'id':5,'href':'/clj-statecharts/docs/get-started/','title':"Get Started",'section':"Docs",'content':"Get Started #  Installation #  Add the dep to to your project.clj/deps.edn/shadow-cljs.edn: \nThe below document assumes you have a require statement like this:\n(require \u0026#39;[statecharts.core :as fsm]) Two layers of APIs #  There are two layers of APIs in clj-statecharts:\n The Immutable API that deals with machines and states directly. This layer is purely functional. The Service API are the higher level one. It is built on top of the immutable API, stateful and easier to get started.  Part 1. The Immutable API #  Simply define a machine, which includes:\n the states and transitions on each state the initial state value the initial context  And use the fsm/initialize and fsm/transition functions.\n;; import proper ns (ns statecharts-samples.basic-immuatable (:require [statecharts.core :as fsm])) ;; define the machine (def machine (fsm/machine {:id :lights :initial :red :context nil :states {:green {:on {:timer {:target :yellow :actions (fn [\u0026amp; _] (println \u0026#34;transitioned to :yellow!\u0026#34;)) }}} :yellow {:on {:timer :red}} :red {:on {:timer :green}}} :on {:power-outage :red} })) (def s1 (fsm/initialize machine)) ; {:_state :red} (def s2 (fsm/transition machine s1 {:type :timer})) ; {:_state :green} (def s3 (fsm/transition machine s2 {:type :timer})) ; {:_state :yellow} (fsm/initialize machine) #  Returns the initial state of the machine. It also executes all the entry actions of the initial states, if any.\nIf you do not want these actions to be executed, use (fsm/initialize machine {:exec false}) instead. The action functions would be collected in the _actions key of the new state map. For example, the test code of clj-statecharts uses this feature to make assertions to ensure correct actions are collected during transitions.\n(fsm/transition machine state event) #  Returns the next state based the current state \u0026amp; event. It also executes all the entry/exit/transition actions.\nIf you do not want these actions to be executed, use (fsm/transition machine state event {:exec false}) instead.\nPart 2. The Service API #  The immutable API provides a clean interface so you can integrate it into your own state management system like re-frame.\nHowever, sometimes it\u0026rsquo;s more convenient to provide a higher level API that could manage the state out of the box. Here comes the service API.\nThe usage pattern for the service API is very simple:\n Define a machine Define a service that runs the machine Send events to trigger transitions on this machine. Use functions like fsm/state or fsm/value to get the state of the service.  ;; import proper ns (ns statecharts-samples.basic (:require [statecharts.core :as fsm])) ;; define the machine (def machine (fsm/machine {:id :lights :initial :red :context nil :states {:green {:on {:timer {:target :yellow :actions (fn [\u0026amp; _] (println \u0026#34;transitioned to :yellow!\u0026#34;)) }}} :yellow {:on {:timer :red}} :red {:on {:timer :green}}} :on {:power-outage :red} })) ;; define the service (def service (fsm/service machine)) ;; start the service (fsm/start service) ;; prints :red (println (fsm/value service)) ;; send events to trigger transitions  (fsm/send service :timer) ;; prints :green (println (fsm/value service)) (fsm/send service :timer) ;; prints :yellow (println (fsm/value service)) "});index.add({'id':6,'href':'/clj-statecharts/docs/guards/','title':"Guarded Transitions",'section':"Docs",'content':"Guarded Transitions #  Use Guarded Transitions #  Also called \u0026ldquo;conditional transitions\u0026rdquo;.\nWhen an event happens, the target state may depend on some condition.\nTo express this, add a :guard key in the transition map.\n The first transition that has is condition met is selected. If none is selected, the event is ignored.  (defn my-condition-fn [state event] ;; returns a boolean ) ;; Part of the machine definition {:states {:s1 {:on {:some-event [{:target :s2 :guard my-condition-fn :actions some-action} {:target :s3}]}}}} If my-condition-fn returns true, then the target is :s2. Otherwise the target would be :s3.\n"});index.add({'id':7,'href':'/clj-statecharts/docs/hierarchical-states/','title':"Hierarchical States",'section':"Docs",'content':"Hierarchical States #  (a.k.a compound states or nested states)\nAbout Hierarchical States (a.k.a Compound States) #  One of the greatest power of statecharts is that it could prevent the \u0026ldquo;states explosion\u0026rdquo; problem of a tradition finite state machine. The power comes from the concept of \u0026ldquo;compound states\u0026rdquo; in statecharts:\n A state can define its sub-states, a.k.a child states If a state doesn\u0026rsquo;t handle an event, its parent would handle it (if it can).  In this sense a statecharts is a tree, and the event is handled by searching from the current node up to the root, until whichever node is found to have specified a handler for this event.\nHere is a more in-depth concept explanation in the StateCharts 101.\nFor example a state machine for a calculator could have a \u0026ldquo;clear screen\u0026rdquo; event that is only handled by the root node.\n{:id :calculator :on {:clear-screen {:target :operand1 :actions (assign reset-inputs)}} {:states {:operand1 {:on {:input-digit :operand1 :input-operator :operator}} :operator {:on {:input-operator :operand2}} :operand2 {:on {:input-digit :operand2 :equals :result}}}}} In a traditional finite state machine, all states would have to handle this event by themselves.\n"});index.add({'id':8,'href':'/clj-statecharts/docs/identifying-states/','title':"Identifying States",'section':"Docs",'content':"Identifying States #  Syntax of State Identifiers #  In describing a transition, we need a way to represent the target state.\nA state is uniquely identified by the vector of its path from the root, with the first element being a special keyword :\u0026gt;.\nFor instance, if we have a state :s1 and it has a child state :s1.1, then they could be identified by [:\u0026gt; :s1] and [:\u0026gt; :s1 :s1.1] respectively.\nThere are other ways to represent a state in transition:\n If the first element of the vector of keywords is not :\u0026gt;, it represents a relative path. A keyword :foo is short for [:foo] If the first element of the vector of keywords is special keyword :., it represents a child state of the current state. A nil target represents a internal self-transition  Some examples:\n{:states {:s1 {:on {:event1_2 :s2 ;; (1) :event_1_1.1 [:. :s1.1]} ;; (2) :states {:s1.1 {:on {:event1.1_1.2 :s1.2 :event1.1_2 [:\u0026gt; :s2] ;; (3) }}}} :s2 {:on {:event_2_2 {:actions some-action}}}}} ;; (4) (1) We want to represent state :s2 in the context of :s1, so we can simply write :s2. We could of course use the absolute syntax [:\u0026gt; :s2].\n(2) :s1.1 is a child state of :s1, and we want to represent it in the context of :s1, which means we can use either the relative syntax [:. :s1.1] or the absolute syntax [:\u0026gt; :s1 :s1.1].\n(3) We want to represent the state :s2 in the context of :s1.1, which means we had to use the absolute syntax here.\n(4) When the target is not given (or nil), it means an internal self-transition.\n"});index.add({'id':9,'href':'/clj-statecharts/docs/parallel-states/','title':"Parallel States",'section':"Docs",'content':"Why Parallel States #  (a.k.a concurrent states or orthogonal regions)\nUsually within a statecharts, all states are tightly related and mutual exclusive to each other (e.g. uploading and uploaded in a file application.).\nHowever, in lots of real world complex applications, there could be multiple \u0026ldquo;regions\u0026rdquo; of the application that are loosely related, or not related at all, but is always used/reasoned together in a module/screen/subsystem.\nFor instance, in a files management application, there could be\n a files list on the main part of the screen, and a \u0026ldquo;properties\u0026rdquo; window that is placed on the right of the screen when a file is selected.  The files list could have the following states:\n list-loading: requesting the list of files from the server list-loaded: successfully get the list of files list-load-failed: error when requesting the list of files, e.g. ajax request fails because of network error  The files property has the following states:\n props-idle: no file is selected, so nothing to show props-loading: file is selected, and requesting the details of the file from the server props-loaded props-load-failed  Most people would feel comfortable to model this screen with two statecharts. But as more features are added, we\u0026rsquo;ll need to create and maintain and reason about more and more disparate statecharts. For instance, each file could have a list of comments, which would pop out when a user clicks a \u0026ldquo;show comments\u0026rdquo; button. Of course we can just add one more new statecharts, but it\u0026rsquo;s obvious to conclude that this doesn\u0026rsquo;t look that appealing, because:\n With the states scattered in more and more multiple places, it becomes harder and harder for us to see and reason about \u0026ldquo;the big picture\u0026rdquo; of the current screen. Part of the statecharts context has to be duplicated among different statecharts, e.g. the current selected file name. Lots of boilerplate. Each state machine requires an id, a call to fsm/machine and fsm.rf/integrate (see re-frame integration for details.)  What is Parallel States #  Parallel states (a.k.a concurrent states) is a mechanism in statecharts that could be used to use a single statecharts to model different parts of an application that doesn\u0026rsquo;t depend on each other. Conceptually:\n when an event comes, each child of a parallel state receives this event at the same time. They could either handle it or ignore it, since some events only makes sense to one part of the screen, e.g. \u0026ldquo;property-loaded\u0026rdquo; should be handled by the props part, but should be ignored by the other parts. The current state of the statecharts is a combination of all parallel children.  How to define a parallel state node #  ;!zprint {:format :on :map {:justify? true} :pair {:justify? true}} {:id :file-app :type :parallel ;; (1) :context {:selected-file-name nil} :regions ;; (2) {:main {:initial :loading ;; (3) :states {:loading {:on {:success-load-files :loaded :fail-load-files :load-failed}} :loaded {} :load-failed {}}} :props {:initial :idle :states {:idle {:on {:file-selected :loading}} :loading {:on {:success-load-props :loaded :fail-load-props :load-failed}} :loaded {} :load-failed {}}}} :comments {:initial :idle :states {:idle {:on {:show-comments :loading}} :loading {:on {:success-load-comments :loaded :fail-load-comments :load-failed}} :loaded {} :load-failed {}}}} (1) Use {:type :parallel} to define a parallel state node\n(2) Define the child regions in the :regions key.\n(3) Each child node of a parallel node must be a hierarchical state node.\nHierarchical parallel state node #  In the example above, the root node of the statecharts is a parallel node. However you can put a parallel node anywhere in the state chart, e.g.:\n{:id :hierarchical-parallel-demo :initial :p2 :states ;; (1) {:p1 ;; (2) {:initial :p11 :states {:p11 {:on {:e12 :p12}} :p12 {}}} ;; p2 is a hierarchical parallel node :p2 ;; (3) {:type :parallel :regions {:p2.a ;; (4) {:initial :p2.a1 :states {:p2.a1 {:on {:e12 :p2.a2}} :p2.a2 {}}} :p2.b ;; (5) {:initial :p2b2 :states {:p2b1 {:on {:e231 :p2b2}} ;; parallel nest level depth +1 :p2b2 {:type :parallel ;; (6) :regions {:p2b2.a {:initial :p2b2.a1 :states {:p2b2.a1 {}}} :p2b2.b {:initial :p2b2.b1 :states {:p2b2.b1 {}}}}}}}}}}} (1) The root node is a hierarchical node, with two regions :p1 and :p2\n(2) :p1 is a hierarchical node\n(3) :p2 is a parallel node with two regions :p2.a and :p2.b\n(4) :p2.a is a hierarchical node\n(5)(6) :p2.b is a hierarchical node, but one of its children :p2b2 is a parallel node.\nWe can build arbitrary complex statecharts this way, but it\u0026rsquo;s highly discouraged because it makes the statecharts harder and harder to reason about.\nState Representation for Parallel Node #   If the fsm root node is a parallel node, then the whole state is represented as a map, e.g. {:r1 :r1-state :r2 :r2-state} In a typical hierarchical node, the current state is represented as [:s1 :s1.1]. However, if :s1.1 is a parallel node and has two regions :r1 and :r2, then it would be represented as [:s1 {:s1.1 {:r1 :r1-state :r2 :r2-state}}].  Advantages and Disadvantages of Parallel States #  Advantages #   A single statecharts spec could as the blueprint of the logic of a coherent module/screen/subsystem, instead of scattered among multiple smaller statecharts. With a better big picture, we could more easily spot places where states design could be improved. Less boilerplate code. Avoid duplication of the same piece of information in the contexts of different statecharts.  Disadvantages #  Nothing.\nSome may say \u0026ldquo;it\u0026rsquo;s more complex\u0026rdquo;. But the complexity is a result of the inheritent complexity of the application itself, not introduced by using parallel nodes in the statecharts. The alternative is to use multiple smaller statecharts. However to keep track and reason about all of these smaller statecharts introduces extra cost both in your code and in your mind.\nSome may worry about \u0026ldquo;there would be a performance impact\u0026rdquo;, since for a parallel state, each event is dispatched to all its child states and in lots of cases some events is only handled by one child state. However, IMO this is hardly a problem given today\u0026rsquo;s hardware technology, unless you\u0026rsquo;re building some nano-second HFT system. For most applications, clj-statecharts takes less than 1ms to process an event.\nUseful links #   Parallel States in StateCharts 101 XState\u0026rsquo;s parallel states support  Note that in xstate the regions are still represented in the states key, which I think is not a good choice since states is also used to represent the children of hierarchical states. So in clj-statecharts we use the :regions key.\n"});index.add({'id':10,'href':'/clj-statecharts/docs/integration/re-frame/','title':"Re-frame Integration",'section':"Docs",'content':"Re-frame Integration #  First, re-frame itself is much like a simple state machine: an event triggers the change of the app-db (much like the context in statecharts), as well as execution of other effects (much like actions in a fsm/statecharts).\nThere are two ways to integrate clj-statecharts with re-frame:\n Integrate re-frame with the immutable api Or integrate with the service api  The statecharts.re-frame namespace provides some goodies for both ways of integration.\nIntegrate re-frame with the Immutable API #  It\u0026rsquo;s pretty straight forward to integrate the immutable API of statecharts into re-frame\u0026rsquo;s event handlers:\n(ns mymodule (:require [re-frame.core :as rf] [statecharts.core :as fsm] [statecharts.integrations.re-frame :as fsm.rf])) (def mymodule-path [(rf/path :mymodule)]) (def my-machine (-\u0026gt; (fsm/machine {:id :mymodule :initial :init :states {...} :integrations {:re-frame {:path mymodule-path ;; (1) :initialize-event :mymodule/init :transition-event :mymodule/fsm-transition}}}) (fsm.rf/integrate) ;; (2) )) The tricky part is to how to use the event system of re-frame to transition the state machine. This is done by fsm.rf/integrate.\nThe call to fsm.rf/integrate would do the following for you:\n register an re-frame event handler for :mymodule/init that calls fsm/initialize and store the resulting state in the given path (i.e. mymodule-path in the this example) register an re-frame event handler :mymodule/fsm-transition, that when triggered, simply calls fsm/transition with the event args.  Here is an example of loading the list of friends of current user:\n(ns statecharts-samples.rf-integration (:require [re-frame.core :as rf] [statecharts.core :as fsm :refer [assign]] [statecharts.integrations.re-frame :as fsm.rf])) (def friends-path [(rf/path :friends)]) (def load-friends (fsm.rf/call-fx {:http-xhrio {:uri \u0026#34;/api/get-friends.json\u0026#34; :method :get :on-failure [:friends/fsm-event :fail-load] :on-success [:friends/fsm-event :success-load]}})) (defn on-friends-loaded [state {:keys [data]}] (assoc state :friends (:friends data))) (defn on-friends-load-failed [state {:keys [data]}] (assoc state :error (:status data))) (def friends-machine (fsm/machine {:id :friends :initial :loading :integrations {:re-frame {:path friends-path :initialize-event :friends/init :transition-event :friends/fsm-event}} :states {:loading {:entry load-friends :on {:success-load {:actions (assign on-friends-loaded) :target :loaded} :fail-load {:actions (assign on-friends-load-failed) :target :load-failed}}} :loaded {} :load-failed {}}})) Notice the use of statecharts.integrations.re-frame/call-fx to dispatch an effect in a fsm action.\nDiscard stale events with epoch support #  Under the [:integrations :re-frame] key, you can specify an epoch? boolean flag. To see why you may need it, first let\u0026rsquo;s see a real world problem.\nImagine there is a image viewing application which users could click one image from a list of thumbnails, and the application would download and show the original high-quality image. Also imagine the download/show is managed by a state machine, so there are states like loading, loaded, load-failed, and events like :load-image, :success-load, :fail-load etc. For instance, upon successful download the image with an ajax request, the :success-load event would be fired, and the machine would enter :loaded state. The UI would then display the image.\nOne problem arises when the user clicks too quickly, for instance, after clicking on image A, and quickly on image B. It\u0026rsquo;s possible that upon successful downloading of image A, the :success-load fires and the UI displays the image A, but the user wants to see image B. (Eventually image B would be displayed, but this \u0026ldquo;flaky\u0026rdquo; experience may annoy users.)\nOne way is to always cancel the current ajax request when requesting for a new one. But sometimes it maybe not feasible to do so. So clj-statecharts provides an epoch? flag in this re-frame integration for such uses cases.\n(-\u0026gt; (fsm/machine {:id :image-viewer :states {...} :integrations {:re-frame {:transition-event :viewer/fsm-event :epoch? true ;; (1) ...}}}) (fsm.rf/integrate)) This epoch? flag would add some extra features to the state:\n Upon the initialize event, the state map would have an _epoch key populated by default, whose value is an integer. Later if you re-initialize the machine, the _epoch key would be automatically incremented by 1. When you dispatch an event to the fsm, typically in a callback function of some async operations like sending an ajax request, you can dispatch a keyword, or a map with an :type key (actually :event-foo is short for {:type :event-foo}. In this map you can pass an :epoch key, which could serve the purpose to automatically discard this event in the :_epoch of the state machine changes.  (ajax/send {:url \u0026#34;http://image.com/imageA\u0026#34; ;; this event is always accepted :callback #(rf/dispatch [:viewer/fsm-event :success-load %])}) (ajax/send {:url \u0026#34;http://image.com/imageA\u0026#34; ;; For this event, when the callback is called, if the provided ;; epoch is not the same as the state\u0026#39;s current _epoch value, the ;; event would be ignored. :callback #(rf/dispatch [:viewer/fsm-event {:type :success-load :epoch 1} %])}) Integrate with the Service API #  When integrating re-frame with the service api of clj-statecharts, the state is stored in the service, and is synced to re-frame app-db by calling to statecharts.integrations.re-frame/connect-rf-db.\n(ns statecharts-samples.rf-integration-service (:require [statecharts.core :as fsm :refer [assign]] [re-frame.core :as rf] [statecharts.integrations.re-frame :as fsm.rf])) (def friends-path [(rf/path :friends)]) (declare friends-service) (rf/reg-event-fx :friends/init (fn [] (fsm/start friends-service) ;; (1) nil)) (defn load-friends [] (send-http-request {:uri \u0026#34;/api/get-friends.json\u0026#34; :method :get :on-success #(fsm/send friends-service {:type :success-load :data %}) :on-failure #(fsm/send friends-service {:type :fail-load :data %})})) (defn on-friends-loaded [state {:keys [data]}] (assoc state :friends (:friends data))) (defn on-friends-load-failed [state {:keys [data]}] (assoc state :error (:status data))) (def friends-machine (fsm/machine {:id :friends :initial :loading :states {:loading {:entry load-friends :on {:success-load {:actions (assign on-friends-loaded) :target :loaded} :fail-load {:actions (assign on-friends-load-failed) :target :load-failed}}} :loaded {} :load-failed {}}})) (defonce friends-service (fsm/service friends-machine)) (fsm.rf/connect-rf-db friends-service [:friends]) ;; (2) (defn ^:dev/after-load after-reload [] (fsm/reload friends-service friends-machine)) ;; (3) (1) call fsm/start on the service in some event handler\n(2) sync the state machine context to some sub key of re-frame app-db with statecharts.integrations.re-frame/connect-rf-db\n(3) Make sure the service keeps a reference to the latest machine definition after hot-reloading.\nBe aware that state is updated into the app-db path in a \u0026ldquo;unidirectional\u0026rdquo; sense. If you update the app-db data (for instance modify the :friends key in the above example), it would not affect the state machine and would be overwritten by the next state machine update.\nImmutable or Service? #  Integrate with the immutable API when:\n The state machine states changes are mostly driven by UI/re-frame events (e.g. button clicks) You need to modify the state directly in other re-frame events  Integrate with the service API when:\n The state changes are mostly driven by non UI/re-frame events (e.g. websocket states management)  Further Reading #   Re-frame EP 003 - Finite State Machines  "});index.add({'id':11,'href':'/clj-statecharts/docs/stores/','title':"Stores",'section':"Docs",'content':"Stores #  clj-statecharts is mostly stateless. But it will often be used in a state-ful environment. The state objects will need to be stored somewhere, in a service, a re-frame db, or somewhere of your choosing.\nOver time events will transition the state objects, which need to be updated in the storage location. Much of the time the events will come from your code calling transition. In these cases, it might be clear how to update the storage location. However if you use delayed transitions clj-statecharts itself needs to update the storage location in the same way that your code would. clj-statecharts does not dictate how the storage works; instead it provides an interface IStore that lets external transitioners coordinate with the internal delayed transitions to update the storage location in the same way.\nMost users of clj-statecharts will not need to understand IStore intimately—they can use a service or one of the existing integrations, which manage an IStore instance internally. However, integration implementors should use this project\u0026rsquo;s examples of how stores are created, connected to schedulers, and used as a facade for initialize and transition. You can find such examples in the implementation of services, the re-frame integration, and in the tests. Search for make-store-scheduler.\n"});index.add({'id':12,'href':'/clj-statecharts/docs/transitions/','title':"Transitions",'section':"Docs",'content':"Transitions #  Transitions are the most important parts of a state machine, since it embodies the major logic of the application.\nBasic Transitions #  The basic elements of a transition is the target state and the actions to execute.\n{:states {:s1 {:on {:event1 {:target :s2 :actions some-action-fn}}}} If the current state is :s1 and event :event1 happens, the new state would be :s2 and the action function some-action-fn would be executed.\nSome syntax sugars:\n{:states {:s1 {:on {:event1 {:target :s2 :actions [action-fn1 action-fn2]} ;; (1) :event2 :s3}}}} ;; (2) (1) The actions could be a vector of multiple action functions to execute.\n(2) If there is no actions, the transition could be simplified to be a single keyword.\nPlease note that event names could be any keywords, with one exception: keywords namespace \u0026ldquo;fsm\u0026rdquo; is considered reserved for clj-statecharts\u0026rsquo;s internal use, so do not use event names like :fsm/foo in your application code.\nInternal \u0026amp; External Transitions #  Before reading this section, make sure you have read the Identifying States about the absolute and relative syntax of representing a state.\nA state could transition to one of its child states.\n If the transition triggers the entry/exit actions on the parent state, it\u0026rsquo;s called an external transition. Otherwise, it\u0026rsquo;s called an internal transition.  Here is an example of an internal \u0026amp; external transition:\n{:states {:s1 {:initial :s1.1 :entry entry1 :exit exit1 :on {:event1_1.2_internal [:. :s1.2] ;; (1) :event1_1.2_external [:\u0026gt; :s1 :s1.2]} ;; (2) :states {:s1.1 {} :s1.2 {}}}}} State :s1 has two child states :s1.1 and :s1.2.\n(1) When event event1_1.2_internal happens, the new state would be :s1.2, but the entry/exit actions of state :s1 would not be executed.\n(2) When event event1_1.2_external happens, the new state would also be :s1.2, but the entry/exit actions of state :s1 would be executed.\nSelf Transitions #  A state could transition to itself, this is called a self-transition.\nFor instance, a calculator FSM could have a state :operand1 representing the state that the user is typing the first operand. So the :input-digit event should keep the state machine in that state (but using actions to update the value of the operand on each input), instead of transitioning to a new state.\nA self-transition could also be either internal or external. To specify an internal self-transition, simply omit the :target key in the transition map.\nFor instance:\n{:states {:s1 {:entry entry1 :exit exit1 :on {:event1_1_internal {:actions some-action} ;; (1) :event1_1_external :s1 ;; (2) }}}} (1) For event :event1_1_internal, the target state is not specified (or nil). In this case, the entry/exit actions of :s1 would not be executed.\n(2) For event :event1_1_external, the target state is explicitly provided as itself, so the entry/exit actions of :s1 would be executed.\nEventLess Transitions #  Quoting XState doc:\n An eventless transition is a transition that is always taken when the machine is in the state where it is defined, and when its guards evaluates to true. They are always checked when the state is first entered, before handling any other events.\n Eventless transitions are defined on the :always key of the state node:\nGiven the following state machine:\n{:states {:s1 {:entry entry1 :exit exit1 :on {:e12 :s2 :actions action12}} :s2 {:entry entry2 :exit exit2 :always [{:guard guard23 :target :s3 :actions action23} {:guard guard24 :target :s4 :actions action23}] :on {:e23 :s3}} :s3 {:entry entry3} :s4 {}}} Assume current state is :s1, and event :e12 happens.\n The target state is :s2. Because :s2 has eventless transitions defined, it would immediately evaluates the guard function guard23. If guard23 returns a truthy value, the machine would transition to state :s3. In this case these actions would be executed one by one:  exit1 action12 entry2 exit2 action23 entry3   Otherwise guard24 would be evaluated. If guard24 returns truthy, the machine would transition to :s4 (and similarly a list of actions would be executed). Otherwise it would stay in :s2.  The event args that accompanies :e12 would be passed to every action that is executed.\n"});})();